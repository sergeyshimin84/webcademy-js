https://www.youtube.com/watch?v=maPRR_jjyOE

2.1 Типы переменных
! По умолчанию используем const,
когда явно понятно что переменная будет менять свое значение,
тогда let.
var стараемся не использовать.

2.2 Типы переменных
string - строка; 
number - число;
boolean - логическое значение;
null - "пустое" значение;
undefined - неопределено;
Значение undefined возникает по ходу работы программы. 
Чтобы самостоятельно обнулить значаение используем null.   
// Структуры данных:
// - Объекты object 
// - Массивы
typeof - оператор для определения типа переменной.
BigInt - большие числа, больше чем 9007199254740991.
Symbol - уникальное примитивное значение.

3. Операторы сравнения и условия
>, <, >=, <= - больше, меньше, больше либо равно, меньше либо равно
== - нестрогое сравнение
=== - строгое сравнение
!= - нестрогое неравенство
!== - строгое сравнение

if (условие) {
    // Код который будет выполнен если условие верно
} else {
    //  Код который будет выполнен если условие НЕ верно
}

Логические операторы
&& - логическое И
|| - логический ИЛИ
! - логический НЕ

4. Тернарный оператор
(условие) ? (условие верно : (условие не верно);

5. Конкатенация строк и шаблонные строки
конкатенация 'строка' + 'строка'
//Используем обратные ковычки, помещаем переменную в строку
console.log(`Привет, ${userName}! Как твои дела?`);

6. Функции
Следуем принципу DRY - don't repeat yourself (не повторяйся).
//Фунции рекомендуется называть глаголом (какое-то действие).

function имя функции(объявление параметров) {
    выполняемый код
}
имя функции() //запускаем фунцию, обращаемся к ней

Существует два типа функций:
// function decloration
function sayHi() {
    console.log('Привет!');
}

// function expression
const seyHi = function () {
    console.log('Привет!');
}

// Плюс function decloration, ее можно объявить до самой функции (считывается сразу).

6.1 Параметры и аргументы для функций
// const userName = 'Марк';
// console.log(`Привет, ${userName}! Как твои дела`);

function sayHi(name) {
    console.log(`Привет, ${name}! Как твои дела`);
}

sayHi('Марк');
sayHi('Олег');
sayHi('Женя');

6.2 return
function summ(a, b) {
    const result = a + b;
    return result;//после return функция завершает работу
}

let res = summ(15, 20);
console.log(res);

6.3 Функции как аргумент
function summ(a, b) {
    return a + b; //без return вместо аргумента возвращался бы undefined
}

const result = summ(summ(10, 15), summ(20, 20)); //функция передается как аргумент
console.log(result);

// колбэк функция (функция обратного вызова вызываемая в другой функции)
function doSomething(func) {
    let result = func(10, 15);
    console.log(result);
}

doSomething(summ);

6.4 Самовызывающаяся функция IIFE
(function () {//Можно не указывать название (ананимная самовызывающаяся функция) 
    console.log('Привет, дорогой пользователь!');
})();//Сразу вызываем функцию

(function (a, b) {
    console.log(a + b);
})(10, 15);

let res = (function (a, b) {
    return a + b;
})(5, 10);
console.log(res);

6.5 Стрелочные функции
// Пример обычной функции
function sayHi(name) {
    console.log(`Привет, ${name}! Как твои дела?`);
}
sayHi('Марк');

function summ (a, b) {
    const result = a + b;
}
summ(15, 15);

// Стрелочные функции
const sayHi2 = (name) => {
    console.log(`Привет, ${name}! Как твои дела?`);
}
sayHi2('Марк');

const summ2 = (a, b) => {
    return a + b;
}
summ2(10, 15);

// Краткая запись стрелочной функции (без фигурных скобок), в случае если выполняеться одно условие
const sayHi3 = (name) => console.log(`Привет, ${name}! Как твои дела?`);
sayHi3('Марк');

const summ3 = (a, b) => a + b;
summ3(5, 15);

7. Массивы
const autoBrands = ['Audi', 'BMW', 'Mazda', 'Toyota'];
console.log(autoBrands);

// Выведем только Audi
console.log(autoBrands[0]);

// Выводим длину массива
console.log(autoBrands.length);

// Можно вкладывать различные занные и другие массивы (но это плохая практика, необьходимо создавать однородные массивы)
const autoBrands2 = ['Audi', 'BMW', true, ['Mazda', 'Toyota'], 70];
console.log(autoBrands2);

7.1 Методы массивов
//Некоторые базовые методы:
arr.push(items) - Добавить элемент в конец массива
arr.pop() - Удалить элемент из конца массива
arr.shift() - Удалить элемент из начала массива
arr/unshift(...items) - Добавить элемент в начало массива
arr.splice([start]), [deketeCount, newElements])

8. Циклы
console.log('Start');

for (let i = 0; i < 10; i++) {
    console.log(i);
}

console.log('Finish');

9. Обход массива иклом for
const autoBrands = ['Audi', 'BMW', 'Mazda', 'Toyota', 'Nissan']; 
console.log(autoBrands.length);

for (let i = 0; i < autoBrands.length; i++) {
    console.log(autoBrands[i]);
}

10. Обход массива циклом for (of)
const autoBrands = ['Audi', 'BMW', 'Mazda', 'Toyota', 'Nissan']; 
// Все элементы из массива autoBrands попадают в переменную brand
for (let brand of autoBrands) {
    console.log(brand);
}

11. Обход массива методом forEach()
const autoBrands = ['Audi', 'BMW', 'Mazda', 'Toyota', 'Nissan'];
// В переменную brand попадают все элементы массива, в i индекс элемента
// Прописываем функцию в качестве аргумента в forEach
autoBrands.forEach(function (brand, i) {
    console.log(`${brand} => ${i}`);
});

// Пример со стрелоочной функцией
autoBrands.forEach((brand, i) => {
    console.log(`${brand} => ${i}`);
});

// Запись в строчку
autoBrands.forEach((brand, i) => {console.log(`${brand} => ${i}`)});

// Создаем функцию отдельно, передаем в forEach в качестве аргумента
function printBrand (brand, i) {
    console.log(`${brand} => ${i}`);
}
autoBrands.forEach(printBrand);

// Пример со стрелоочной функцией
const printBrand2 = (brand, i) => {
    console.log(`${brand} => ${i}`);
}
autoBrands.forEach(printBrand2);

12. Обьекты
// Свойства объектов
let userName = 'Марк' 
let age = 30;
let isMArried = false;

const person = {
    userName: 'Марк', 
    age: 30,
    isMArried: false
}

console.log(person);
console.log(person.userName);
console.log(person['age']);

// Добавляем свойство объекта
person.profession = 'JS developer';
console.log(person);

// Удаляем свойство
delete person.age;
console.log(person);

13. Методы в объектах
// Метод в который записана функция называется методом объекта 
const person = {
    userName: 'Марк', 
    age: 30,
    isMArried: false,
    sayHi: function () {
        console.log('Привет!');
    }
};
// Вызываеться как функциия
person.sayHi();

const person = {
    userName: 'Марк', 
    age: 30,
    isMArried: false,
    sayHi: function (name) {
        console.log(`Привет, ${name}!`);
    }
};
person.sayHi('Олег');

13. Методы в объектах
// Метод в который записана функция называется методом объекта 
const person = {
    userName: 'Марк', 
    age: 30,
    isMArried: false,
    sayHi: function (name) {
        console.log(`Привет, ${name}!`);
    }
};
// Вызываеться как функциия
person.sayHi('Олег');

14. Ключевое слово this
const person2 = {
    userName: 'Сергей', 
    age: 40,
    isMArried: true,
    sayHi: function (name) {
        console.log(`Привет, ${name}! Меня зовут ${person2.userName}.`);
    }
};
person2.sayHi('Андрей');
// this ссылаеться сразу на объект
const person3 = {
    userName: 'Сергей', 
    age: 40,
    isMArried: true,
    sayHi: function (name) {
        console.log(this);
        console.log(`Привет, ${name}! Меня зовут ${this.userName}.`);
    }
};
person3.sayHi('Андрей');

15. Объекты обход циклом for in
// for in может обходить не итерируемые объекты
const person = {
    userName: 'Сергей', 
    age: 40,
    isMArried: true,
    sayHi: function (yourName) {
        console.log(`Привет, ${yourName}! Меня зовут ${this.userName}.`);
    }
};
person.sayHi('Андрей');

for (let key in person) {
    console.log(key, ':', person[key]);
}

17. Классы. Конструкторы объектов
// Опишем класс, это как шаблон для всех будущих объектов person которые будут создаваться на его основе
class Person {
    // constructor - функция, которая принимает значения
    constructor (userName, age, isMArried) {
        this.userName = userName;
        this.age = age;
        this.isMArried = isMArried;
    }
    // Добавляем новый метод sayHi, он доступен всем объектам на основе класса Person 
    sayHi(yourName) {
        console.log(`Привет, ${yourName}! Меня зовут ${this.userName}.`);
    }
}

const person1 = new Person('Марк', 30, false);
const person2 = new Person('Павел', 28, true);
console.log(person1, person2);
// Используем новый метод seyHi в объектах
person1.sayHi('Юрий');
person2.sayHi('Юрий');

Выбор DOM элементов

// Выбор одного элеменнта DOM по селектору
// document.querySelector('selector'); 
// Обращаемся к глобальному объекту браузера document (querySelector выбирает первый элемент на странице, поиск происходит сверху вниз)

const header = document.querySelector('h2');
console.log(header);

header.classList.add('red');

document.querySelector('.heading-3').classList.add('green');

// Выбор коллекции элементов
const headings = document.querySelectorAll('h2');
console.log(headings);
// Нашшли все заголовки, пробижаллись циклом for of, добавили к каждому класс .red-text
for (let heading of headings) {
    console.log(heading);
    heading.classList.add('red-text');
}
// Нашшли все заголовки, пробижаллись циклом for of, добавили к каждому класс .green-text
const paragraphs = document.querySelectorAll('p');
for (let p of paragraphs) {
    console.log(p);
    p.classList.add('green-text');
}
// Пример с forEach
paragraphs.forEach(function (item) {
    item.classList.add('green-text');
})

// Также есть следующие методы
document.getElementsByClassName();// выбор по имени класса
document.getElementsByTagName();// выбор по тегу
document.getElementById('');// выбор по id

Работа с CSS классами
/* 
element.classList.add()
.add() добавляет класс
.remove() удаляет класс
.toggle() добавляет или удаляет класс при его наличии ("переключатель"). 
Когда toggle добавляет класс, возвращает true, когда убиррает false.
.contaiins() проверяет наличие класса у элемента. Возвращает true или false.
*/

const heading = document.querySelector('h2');
console.log(heading);

heading.classList.add('red-text');
heading.classList.remove('red-text');
heading.classList.toggle('green-text');
heading.classList.toggle('green');

Работа с атрибутами
/*
getAttribute(attrName) - возвращает значение указанного атрибута
setAttribute(name, value) - добавляет указанные атрибуты и его значения к элементу
hasAttribute(attrName) - возвращает true при наличии у элемента указанного атрибута
removeAttribute(attrName) - удаляет указанный атрибут
*/

// получаем элемент по id
const img = document.querySelector('#logo');
const srcValue = img.getAttribute('src');
console.log(srcValue);

// меняем значение атрибута src (заменяем картинку)
// первым занчением добавляем/обращаемся к атрибуту, вторым значением прописываем его свойства
img.setAttribute('src', './img/php.png');
// указываем ширину картинки
img.setAttribute('width', '200');
// к некоторым атрибутам возможно обратиться на прямую
img.src = './img/js.png';
// проверяем есть ли атрибут, возвращает true или false
console.log(img.hasAttribute('src'));
// удаляем атрибут ширины картинки
img.removeAttribute('width');

const button = document.querySelector('#button');
button.setAttribute('value', 'Отправить');
button.value = 'Текст для кнопки';

Работа с прослушкой событий

// находим кнопку
const button = document.querySelector('#button');
// ноходим картинку
const img = document.querySelector('#logo');
// меняем название кнопки
button.value = 'удалить';
// прослушиваем событие клик (позволяет прописать множество действий при клике)
button.addEventListener('click', function() {
    console.log('click!');
    img.remove();
});
// onclick совершает указанное действие при клике (в последующем только перезаписываеться)
button.onclick = function () {
    console.log('click1!');
};

Прослушка событий 2. Форма

const inputText = document.querySelector('#input-text');
const textBlock = document.querySelector('#text-block');

// inputText.addEventListener('input', () => {
//     console.log(inputText.value);
//     textBlock.innerText = inputText.value;
// })

inputText.addEventListener('input', inputHandler);

function inputHandler() {
    console.log(inputText.value);
    textBlock.innerText = inputText.value;
};

Объект event

const list = document.querySelector('#list');
// Объект event являетс первым параметром функции addEventListener
list.addEventListener('click', (event) => {
    // this ссылаеться на родителя с #list (у которого слушаем addEventListener)
    console.log(this);
    // Объект event получает всю информацию о html элементе спровоцировавшим событие ('click') 
    console.log(event);
    // Свойство target получает информацию о том html элементе который спровоцировал событие ('click') 
    console.log(event.target);
})

Работа с элементами

/*
// Создать элемент
document.createElement('tag-name')

// Изменить HTML содержимое внутри элемента
element.innerHTML = ''

// Изменить текстовое содержимое внутри элемента
none.innerText = ''

// Клонирование элемента
node.cloneNode() // true с внутренним содержанием (текста и теги),
false - без внутреннего содержания

// Вставить элемент внутрь другого элемента
element.append(nodesOrDOMStrings)

// Удалить элемент
element.remove()
*/

// Выбор контейнера
const container = document.querySelector('#elementsContainer');

// Создание загловка
const newHeader = document.createElement('h1');
newHeader.innerText = 'Новый заголовок';
container.append(newHeader);

// Копирование шапки
const mainHeader = document.querySelector('header');
// Для копирования всего содержимого тега в метод cloneNode передаем true 
const headerCopy = mainHeader.cloneNode(true);
// Вставляем элемент в container
container.append(headerCopy);

// Вставка разметки через строку
const htmlExample = '<h2>Еще один заголовок</h2>';
container.insertAdjacentHTML('beforeend', htmlExample);

// Вставка разметки через шаблонные строки
const title = 'Текст заголовка';
// Передаем текст через шаблонную строку
const htmlExample2 = `<h2>${title}</h2>`;
container.insertAdjacentHTML('beforeend', htmlExample2);

ToDo список задач
https://learn.javascript.ru/introduction-browser-events

const todoList = document.querySelector('#todo-list');
const todoForm = document.querySelector('#todo-form');
const todoInput = document.querySelector('#todo-input');

todoForm.addEventListener('submit', formHandler);

Вариант 1
function formHandler(event) {
    event.preventDefault();

    // Получаем значение из поля ввода (инпута)
    const taskText = todoInput.value;

    // Создаем тег li через разметку
    const li = `<li>${taskText}</li>`;

    // Добавляем разметку на страницу
    todoList.insertAdjacentHTML('beforeend',  li);

    // Очищаем поле ввода (инпут)
    todoInput.value = '';
    
    // Фокус на поле ввода
    todoInput.focus();
    
}

Вариант 2
function formHandler(event) {
    event.preventDefault();

    // Получаем значение из поля ввода (инпута)
    const taskText = todoInput.value;

    // Создаем тег li через разметку
    // const li = `<li>${taskText}</li>`;

    // Добавляем разметку на страницу
    // todoList.insertAdjacentHTML('beforeend',  li);

    // Создаем тег li с помощью создания элемента (в последующем можем модифицировать, добавлять элементы)
    const newTask = document.createElement('li');
    newTask.innerText = taskText;
    console.log(newTask);

    // Создаем кнопку удалить
    const deleteBtn = document.createElement('button');
    deleteBtn.setAttribute('role', 'button'); //Назначена роль кнопка
    deleteBtn.innerText = 'Удалить';
    deleteBtn.style['margin-left'] = '15px';
    newTask.append(deleteBtn);
    console.log(newTask);
    deleteBtn.addEventListener('click', function () {
        // newTask.remove() //Простое удаление элемента
        
        // Обращаемся к родительскому элементу через this, ищем ближайшего предка,
        // который соответствует CSS-селектору 'li' с помощью closest, удаляем его (более точное описание удаления)
        this.closest('li').remove();
    });

    // Добавляем элемент на страницу
    todoList.append(newTask)

    // Очищаем поле ввода (инпут)
    todoInput.value = '';
    
    // Фокус на поле ввода
    todoInput.focus();
}

setInterval
// Позволяет запускать код с определенной периодичностью
// Первым аргументом передается функция, вторым время в мс
const timeIntervalID = setInterval(function () {
     console.log('Approved!');
}, 2000);
// Прекращает работу setInterval (возвращает id, отследив его прекращает работу) 
clearInterval(timeIntervalID);

setTimeout
// Запускает работу функции через определенное время
const timerID = setTimeout(function () {
     console.log('setTimeout Approved!');
}, 2000);
// Прекращает работу setTimeout
clearInterval(timerID);

setInterval + setInterval
const timerID = setInterval(function () {
     console.log('setInterval ON');
}, 1000)

setTimeout(function () {
     clearInterval(timerID);
     console.log('setInterval OFF');
}, 10000)

Collback, Collback hell
// Обратный вызов, это функции которые передаются в другие функции и вызываются после их завершения
//Collback (обратный вызов)
// 1. Проверяем номера в отеле
// 2. Проверяем авиобилеты
// function checkRooms(){
//     setTimeout(function(){
//         console.log('Проверяем номера в отеле...');
//         const availableRooms = false;

//         if (availableRooms) {
//             console.log('Номера есть!');
//             console.log('Едем в отпуск! :)');
//         } else {
//             console.log('Номеров нет.');
//             console.log('Отпуск отменяется :(');
//         }
//     }, 1000)
// }
// При проверке номеров в отеле вродебы все работает, но если добавить еще одно действие...
// checkRooms();

function checkRooms(){
    setTimeout(function(){
        console.log('Проверяем номера в отеле...');
        const availableRooms = true;

        if (availableRooms) {
            let message = 'Номера есть';
            sumbitVacation(message)
        } else {
            let message = 'Номеров нет';
            cancelVacation(message)
        }
    }, 1000)        
}

checkRooms();

function cancelVacation(message) {
    console.log('---cancelVacation---');
    console.log('Ответ на предыдцщем шаге:', message);
    console.log('Отпуск отменяется :(');
}

function sumbitVacation(message) {
    console.log('---sumbitVacation---');
    console.log('Ответ на предыдцщем шаге:', message);
    console.log('Едем в отпуск! :)');
}

// Сделаем функцию более универсальной
function checkRooms(success, failed){
    setTimeout(function(){
        console.log('Проверяем номера в отеле...');
        const availableRooms = true;

        if (availableRooms) {
            let message = 'Номера есть';
            success(message);
        } else {
            let message = 'Номеров нет';
            failed(message);
        }
    }, 1000)        
}
// передаем в качестве аргументов функции sumbitVacation и cancelVacation
checkRooms(sumbitVacation, cancelVacation);

function cancelVacation(message) {
    console.log('---cancelVacation---');
    console.log('Ответ на предыдцщем шаге:', message);
    console.log('Отпуск отменяется :(');
}

function sumbitVacation(message) {
    console.log('---sumbitVacation---');
    console.log('Ответ на предыдцщем шаге:', message);
    console.log('Едем в отпуск! :)');
}

function checkRooms(success, failed){
    setTimeout(function(){
        console.log('Проверяем номера в отеле...');
        const availableRooms = true;

        if (availableRooms) {
            let message = 'Номера есть';
            success(message);
        } else {
            let message = 'Номеров нет';
            failed(message);
        }
    }, 1000)        
}

function checkTickets(message, success, failed) {
    setTimeout(function(){
        console.log('---- function checkTickets ----');
        console.log('Ответ на предыдущм шаге:', message);

        console.log('Проверяем авиабилеты...');
        const availableTickets = true;

        if (availableTickets) {
            let message = 'Билеты есть';
            success(message);
        } else {
            let message = 'Билетов нет';
            failed(message);
        }
    }, 500)
}

function cancelVacation(message) {
    console.log('---cancelVacation---');
    console.log('Ответ на предыдцщем шаге:', message);
    console.log('Отпуск отменяется :(');
}

function sumbitVacation(message) {
    console.log('---sumbitVacation---');
    console.log('Ответ на предыдцщем шаге:', message);
    console.log('Едем в отпуск! :)');
}

// передаем в качестве аргументов функции sumbitVacation и cancelVacation
// Collback hell разрастаеться, код уходит вправо
checkRooms(
    function(messageFromCheckRooms){
        checkTickets(
            messageFromCheckRooms, 
            function(messageFromCheckRooms){
                sumbitVacation(messageFromCheckRooms)
            },
            function(messageFromCheckTickets){
                cancelVacation(messageFromCheckTickets)
            })
    }, 
    function(messageFromCheckRooms){
        cancelVacation(messageFromCheckRooms)
    }
);

Создание промиса

const myPromise = new Promise(function (resolve, reject){
    console.log('Promise created');
    setTimeout(function(){
        const response = true;

        if (response) {
            let message = 'SUCCESS'
            resolve(message);
        } else {
            let message = 'FAILED'
            reject(message);
        }
    }, 1500)
});

myPromise.then(function(data){
    setTimeout(() => {
        console.log('Then 1');
        console.log(data);
    }, 1000)
}).then(function(data){
    setTimeout(() => {
        console.log('Then 2');
    }, 500)
}).catch(function(data){
    console.log('Catch');
    console.log(data);
})

Привер корректного кода:
const myPromise = new Promise(function (resolve, reject){
    console.log('Promise created');
    setTimeout(function(){
        const response = true;

        if (response) {
            let message = 'SUCCESS'
            resolve(message);
        } else {
            let message = 'FAILED'
            reject(message);
        }
    }, 1500)
});
// для гарантированного последовательного выполения ассинхроннго кода необходимо оборачивать в Promise каждый then
myPromise.then(function(data){
    return new Promise(function(resolve, reject){
        setTimeout(() => {
            console.log('Then 1');
            console.log(data);

            const response = false;
            if (response) {
                resolve('Data from then 1')
            } else {
                reject('Data from then 1')
            }
        }, 1000)
    })
    
}).then(function(data){
    setTimeout(() => {
        console.log('Then 2');
        console.log(data);
    }, 500)
}).catch(function(data){
    console.log('Catch');
    console.log(data);
})


Цепочка промисов. Несколько промисов с setTimeout

const checkRooms = new Promise(function(resolve, reject){
    setTimeout(function () {
        console.log('Проверяем номера в отеле...');
        const availableRooms = true;

        if (availableRooms) {
            resolve('Номера есть!');
        } else {
            reject('Номеров нет.');
        }
    }, 1500)
});
// в then попадает успешный результат resolve
// checkRooms.then(function(data){
//     console.log('--- then 1 ---');
//     console.log('Ответ на предыдущем шаге:', data);
//     console.log('Едем в отпуск! :)');
// в catch попадает результат с ошибкой reject  
// }).catch(function(data){
//     console.log('--- catch ---');
//     console.log('Ответ на предыдущем шаге:', data);
//     console.log('Отпуск отменяеться :(');
// })

checkRooms.then(function(data){
    return new Promise(function(resolve, reject){
        setTimeout(() => {
            console.log('--- then 1 ---');
            console.log('Ответ на предыдущем шаге:', data);
            console.log('Проверяем авиабилеты...');
            const availableTickets = true;
        
            if (availableTickets) {
                let message = 'Билеты есть!';
                resolve(message)
            } else {
                let message = 'Билетов нет';
                reject(message);
            }
        }, 1000)
    })
}).then(function(data){
    console.log('--- then 2 ---');
    console.log('Ответ на предыдущем шаге:', data);
    console.log('Едем в отпуск! :)');
}).catch(function(data){
    console.log('--- catch ---');
    console.log('Ответ на предыдущем шаге:', data);
    console.log('Отпуск отменяеться :(');
})

Цепочка промисов. Отдельные функции. Несколько промисов с setTimeout

checkRooms()
    .then(checkTickets)
    .then(success)
    .catch(failed);

function checkRooms (){
    return new Promise(function(resolve, reject){
        setTimeout(function () {
            console.log('Проверяем номера в отеле...');
            const availableRooms = true;
    
            if (availableRooms) {
                resolve('Номера есть!');
            } else {
                reject('Номеров нет.');
            }
        }, 1500)
    });
}

function checkTickets(data){
    return new Promise(function(resolve, reject){
        setTimeout(() => {
            console.log('--- then 1 ---');
            console.log('Ответ на предыдущем шаге:', data);
            console.log('Проверяем авиабилеты...');
            const availableTickets = true;
        
            if (availableTickets) {
                let message = 'Билеты есть!';
                resolve(message)
            } else {
                let message = 'Билетов нет';
                reject(message);
            }
        }, 1000)
    })
}

function success(data){
    console.log('--- success ---');
    console.log('Ответ на предыдущем шаге:', data);
    console.log('Едем в отпуск! :)');
}

function failed(data) {
    console.log('--- failed ---');
    console.log('Ответ на предыдущем шаге:', data);
    console.log('Отпуск отменяеться :(');
}

